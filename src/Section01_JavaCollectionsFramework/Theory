//////////Lesson01//////////
Java collections framework - набор связанных классов и интерфейсов реализующих функционал по хранению объектов.

Коллекция - это набор объектов. То место где мы храним наши объекты и есть коллекция.

Класс ArrayList - это класс реализующий функционал динамического массива, то есть массива, который расширяется
при добавлении новых объектов в него. Классический массив имеет фиксированный размер.

Когда мы используем класс из коллекций, когда создаем объект этого класса, лучше ссылать ArrayList на переменную List

//////////Lesson02//////////
При создании нового объекта ArrayList у него создается внутренний массив, и размер этого массива по умолчанию равен 10.
В аргументах указывается размер массива.
При увеличении массива создается новый массив, и все элементы из старого переносятся в новый.

//////////Lesson03//////////
LinkedList и ArrayList реализуют одинаковый интерфейс List, и методы у них одинаковые.
Однако они имеют разную реализацию. ArrayList хранит информацию во внутреннем массиве.
LinkeddList имеет другую структуру хранения информации. Вместо массива он имеет цепочку узлов. Иными словами цепочка объектов, и у каждого объекта есть ссылка на следующий объект. В каждом узле есть само значение и ссылка на следующий узел.
LinkedList - удаление элементов из листа или запись в начало листа.
ArrayList - Много записей в конец листа или много считываний из листа.

//////////Lesson04//////////
Есть 2 вида связанных списков (LinkedList) - односвязный список и двусвязный. В java LinkedList реализуется двусвязный.
У односвязного списка есть ссылка только на следующий узел. У двусвязного ссылка есть и на следующий и на предыдущий. 

//////////Lesson05//////////
интерфейс map - это структура данных хранящая данные в виде <ключ, значение>. Каждое значение можно найти по его ключу.
При создании объекта HashMap который ссылается на интерфейс map нужно указать тип значений и ключей в угловых скобках через запятую.
Если записать новое значение с ключом который уже был, то значение перезапишется. Дубликатов ключей быть не может. При дубликате старое значение меняется на новое. Дубликаты значений могут быть. 
Метод get дает значение ключа. 
Элементы ключ значение в hashmap не имеют какого либо порядка. 
hashmap надо использовать когда порядок пар ключ значения неважен.
Слабая сторона hashMap заключается в отсутствии порядка. Данные (пары ключ-значение) могут выдаваться случайным образом.

//////////Lesson06//////////
linkedHashMap - сохраняет порядок добавления новых пар ключ-значение в map. 
TreeMap - сортирует пары ключ-значение по ключу. 

//////////Lesson07//////////
Set - коллекция которая хранит в себе только уникальные элементы. В множестве не может быть одинаковых элементов. Дубликаты игнорируются. 
Объекты класса set хранят в себе обычные объекты. Не пары ключ-значение. List и Set во многом похожи между собой. 
Все классы реализующие интерфейс set реализуют метод toString. 
Пересечение - a.intersect(b) a(0 - 100) b(50 - 150). Хотим получить значение которое находится и внутри a и внутри b (50 - 100)
Объединение - a.union(b). a(0 - 100) b(50 - 150). Получим c(0 - 150)
Разность - a.subtract(b). a(0 - 100) b(50 - 150). Убираем от a все что есть в b.

//////////Lesson08 - Lesson09//////////
equals - принимает в качестве аргумента ссылочную переменную и проверяет, ссылается ли они на тот же объект (ту же область памяти, если быть точнее), что и объект, к которому мы применили метод .equals().
hashcode - это метод для получения уникального целочисленного номера объекта, своего рода его идентификатор. Благодаря хешу (номеру) можно, например, быстро определить местонахождение объекта в коллекции.
Данные методы всегда нужно переопределять в созданных нами классах, иначе они будут наследоваться от класса Object. 
Метод equals работает дольше чем hashcode. Первым при проверке объектов на одинаковость вызывается метод hashcode. И если метод отработал правильно мы заканчиваем. 
Если же нет - вызывается метод equals который в любом случае выдаст правильный ответ.
Хэширование - преобразование массива данных произвольной длинны в (выходную) битовую строку фиксированной длинны. (Преобразуется что-то произвольной длинны во что-то фиксированной длинны).
Если хэшкоды объектов равны это не значит что объекты равны. 
Явление когда хешкоды равны а объекты нет называются коллизией. Она возникает по той причине что количество хешкодов ограничено. В момент коллизии надо вызывать метод equals. 


























 